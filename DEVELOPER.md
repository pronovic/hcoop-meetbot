# Developer Notes

## Supported Platforms

This plugin was written and tested on Debian GNU/Linux, but should also work on MacOS.  The code itself is portable, but Limnoria (Supybot) doesn't always work as expected on Windows, so it's best not to try.

## Architecture and Test Design

Limnoria (Supybot) plugins are quite specialized, with a standard code structure and a dedicated test framework.  For this implementation, I have chosen to make the Limnoria plugin in [`HcoopMeetbot`](src/HcoopMeetbot) as a very thin wrapper over functionality implemented in the companion [`hcoopmeetbotlogic`](src/hcoopmeetbotlogic) package.  The interface has been abstracted, and the backend logic is not even aware of Limnoria.  By using this design, we can minimize the testing needed to prove that the plugin is wired up properly.  It's also easier to unit test the business logic, and easier to apply code checks like MyPy.  

There are two different test suites.  The first, in [`src/HcoopMeetbot/test.py`](src/HcoopMeetbot/test.py), is the Limnoria test suite.  This must be executed via `supybot-test` &mdash; you can't run it any other way.  The second, in the [`tests`](tests) package, is a standard Pytest suite.  The `run test` task (discussed below) executes both suites and combines the coverage results together into a single report.

## Packaging and Dependencies

This project uses [Poetry](https://python-poetry.org/) to manage Python packaging and dependencies.  Most day-to-day tasks (such as running unit tests from the command line) are orchestrated through Poetry.  

A coding standard is enforced using [Black](https://github.com/psf/black), [isort](https://pypi.org/project/isort/) and [Pylint](https://www.pylint.org/).  Python 3 type hinting is validated using [MyPy](https://pypi.org/project/mypy/).  Additional code security standards are enforced [Safety](https://github.com/pyupio/safety).

## Pre-Commit Hooks

We rely on pre-commit hooks to ensure that the code is properly-formatted, clean, and type-safe when it's checked in.  The `run install` step described below installs the project pre-commit hooks into your repository.  These hooks are configured in [`.pre-commit-config.yaml`](.pre-commit-config.yaml).

If necessary, you can temporarily disable a hook using Git's `--no-verify` switch.  However, keep in mind that the CI build on GitHub enforces these checks, so the build will fail.

## Line Endings

The [`.gitattributes`](.gitattributes) file controls line endings for the files in this repository.  It would be simplest to have files in the Git working copy use native line endings.  However, I develop this code on multiple platforms, and the files in the published PyPI package get the line endings from the working copy.  If we use native line endings, the format of the published package will vary depending on where the publish step was run.  This is confusing, and can cause problems for downstream users who expect the PyPI package to have a consistent format.  Instead of relying on automatic behavior, the `.gitattributes` file forces most files to have UNIX line endings.  

This generally works ok, except for the [`docs/requirements.txt`](docs/requirements.txt) file generated by Poetry.  Unfortunately, all of the files that Poetry generates have native platform line endings, and you can't override that behavior.  Even with sane configuration in `.gitattributes`, you sometimes still get spurious differences, where Git says that a file has changed but then `git diff` shows an empty result.  The `run` script and the pre-commit hooks both normalize the line endings for `requirements.txt` using [`utils/dos2unix.py`](utils/dos2unix.py).  I wish there were a standard way to do this in Poetry or in Python, but there isn't as of this writing.

## Prequisites

Nearly all prerequisites are managed by Poetry.  All you need to do is make sure that you have a working Python 3 enviroment and install Poetry itself.  

### MacOS

On MacOS, it's easiest to use [Homebrew](https://brew.sh/):

```
$ brew install python3
$ brew install poetry
```

When you're done, you probably want to set up your profile so the `python` on your `$PATH` is Python 3 from Homebrew (in `/usr/local`).  By default, you'll get the standard Python 2 that comes with MacOS.

### Debian

First, install Python 3 and related tools:

```
$ sudo apt-get install python3 python3-venv python3-pip
```

Once that's done, make sure Python 3 is the default on your system.  There are a couple of ways to do this, but using `update-alternatives` as discussed on [StackOverflow](https://unix.stackexchange.com/a/410851) is probably the best.

Then, install Poetry in your home directory:

```
$ curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python
```

## Configure Poetry's Python Interpreter

At this point, you can either let Poetry use its defaults, or tell it explicity which Python interpreter you want it to use.  On MacOS anyway, Poetry >= v1.1.3 seems to be quite aggressive about using the most recent version of Python available on my system (even if it's not on my `$PATH`), which is not always what I want.

To force Poetry to use a particular version of Python on the `$PATH`, do this:

```
$ poetry env use 3.8
```

To force Poetry to use a version that isn't on the `$PATH`, you can't just use the version number as shown above.  You have to provide the whole path:

```
$ poetry env use /usr/local/Cellar/python@3.9/3.9.0/bin/python3.9
```

You can check the version that is in use with:

```
$ poetry env info
```

If you switch between versions, it is a good idea to sanity check what is actually being used.  I've noticed that if I start on 3.8 and then switch to 3.9 (in the order shown above), then `python env info` still reports Python 3.8.6 when I'm done.  The fix seems to be to remove the virutalenvs and start over:

```
$ poetry env list
$ poetry env remove <item>
```

For more background, see [this discussion](https://github.com/python-poetry/poetry/issues/522) and also [Poetry PR #731](https://github.com/python-poetry/poetry/pull/731).

## Activating the Virtual Environment

Poetry manages the virtual environment used for testing.  Theoretically, the Poetry `shell` command gives you a shell using that virutalenv.  However, it doesn't work that well.  Instead, it's simpler to just activate the virtual environment directly.  The [`run`](run) script has an entry that dumps out the correct `source` command. Otherwise, see [`notes/venv.sh`](notes/venv.sh) for a way to set up a global alias that activates any virtualenv found in the current directory.

## Developer Tasks

The [`run`](run) script provides shortcuts for common developer tasks:

```
$ run --help

------------------------------------
Shortcuts for common developer tasks
------------------------------------

Usage: run <command>

- run install: Setup the virtualenv via Poetry and install pre-commit hooks
- run activate: Print command needed to activate the Poetry virtualenv
- run requirements: Regenerate the docs/requirements.txt file
- run format: Run the code formatters
- run checks: Run the code checkers
- run test: Run the unit and supybot tests
- run test -c: Run the unit and supybot tests with coverage
- run test -ch: Run the tests with coverage and open the HTML report
- run docs: Build the Spinx documentation for hcoop-meetbot.readthedocs.io
- run docs -o: Build the Spinx documentation and open in a browser
- run tox: Run the Tox test suite used by the GitHub CI action
- run release: Release a specific version and tag the code
- run publish: Publish the current code to PyPI and push to GitHub
- run bot: Run a bot connected to an IRC server on localhost
```

## Local Testing

TODO: need to come up with a way to template-ize the localbot.conf file, since it contains absolute paths

Local testing is straightforward.  Instructions below are for Debian, but setup should be similar on other platforms.

First, install an IRC server.  The [InspIRCd](https://www.inspircd.org/) server works well and there are are Debian-specific install [instructions](https://wiki.debian.org/InspIRCd) if you need more help:

```
$ sudo apt-get install inspircd
```

Next, install an IRC client.  Any client is ok, but [Irssi](https://irssi.org/) works well:

```
$ sudo apt-get install irssi
```

Once the IRC server is up, make sure you can connect with the client:

```
$ irssi --nick=ken --connect=localhost
```

Once you are connected, join the testing channel with `/join #localtest`.

Finally, open another terminal window and run the bot:

```
$ run bot
Running the local bot...
INFO 2021-02-14T17:06:34 Connecting to localhost:6667.
WARNING 2021-02-14T17:06:34 Error connecting to localhost:6667: ConnectionRefusedError: [Errno 111] Connection refused
INFO 2021-02-14T17:06:34 Reconnecting to LocalNet at 2021-02-14T17:06:44.
INFO 2021-02-14T17:06:44 Connecting to localhost:6667.
INFO 2021-02-14T17:06:50 Server irc.local has version InspIRCd-2.0
INFO 2021-02-14T17:06:50 Got start of MOTD from irc.local
INFO 2021-02-14T17:06:50 Got end of MOTD from irc.local
INFO 2021-02-14T17:06:54 Join to #localtest on LocalNet synced in 4.01 seconds.
```

Notice that this takes a few seconds to complete.  Once it's done, if you look over in your IRC window, you should see a notification that the local bot has joined the `#localtest` channel:

```
17:09 -!- localbot [limnoria@127.0.0.1] has joined #localtest
```

You can now interact with the local bot using `localbot: <command>`, or using `@<command>` as a shortcut.  

The `HcoopMeetbot` plugin is automatically available in the bot.  If you make changes to the code, you need to stop the bot with CTRL-C and restart it.

## Integration with PyCharm

By integrating Black and Pylint, most everything important that can be done from a shell environment can also be done right in PyCharm.

Unfortunately, it is somewhat difficult to provide a working PyCharm configuration that other developers can simply import. There are still some manual steps required.  I have checked in a minimal `.idea` directory, so at least all developers can share a single inspection profile, etc.

### Prerequisites

Before going any further, make sure sure that you installed all of the system prerequisites discussed above.  Then, make sure your environment is in working order.  In particular, if you do not run the install step, there will be no virtualenv for PyCharm to use:

```
$ run install
$ run test
$ run checks
```

Once you have a working shell development environment, **Open** (do not **Import**) the `hcoop-meetbot` directory in PyCharm and follow the remaining instructions below.  (By using **Open**, the existing `.idea` directory will be retained.)  

### Project and Module Setup

Run the following to find the location of the Python virtualenv managed by Poetry:

```
$ poetry run which python
```

#### PyCharm

Go to settings and find the `hcoop-meetbot` project.  Under **Python Interpreter**, select the Python virtualenv from above.

Under **Project Structure**, mark both `src` and `tests` as source folders.  In the **Exclude Files** box, enter the following:

```
CREDITS;LICENSE;PyPI.md;.coverage;.coveragerc;.github;.gitignore;.gitattributes;.htmlcov;.idea;.isort.cfg;.mypy.ini;.mypy_cache;.pre-commit-config.yaml;.pylintrc;.pytest.ini;.pytest_cache;.readthedocs.yml;.tox;.toxrc;build;dist;docs/_build;out;poetry.lock;run;.tabignore;localbot
```

Finally, go to the gear icon in the project panel, and uncheck **Show Excluded Files**.  This will hide the files and directories that were excluded above.

### Preferences

Unit tests are written using [Pytest](https://docs.pytest.org/en/latest/), and API documentation is written using [Google Style Python Docstring](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html).  However, neither of these is the default in IntelliJ or PyCharm.

In settings, go to **Tools > Python Integrated Tools**.  Under **Testing > Default test runner**, select _pytest_.  Under **Docstrings > Docstring format**, select _Google_.

### Running Unit Tests

Right-click on the `tests` folder in the project explorer and choose **Run 'pytest in tests'**.  Make sure that all of the tests pass. 

### External Tools

Optionally, you might want to set up external tools in PyCharm for some of common developer tasks: code reformatting and the PyLint and MyPy checks.  One nice advantage of doing this is that you can configure an output filter, which makes the Pylint and MyPy errors clickable in IntelliJ.  To set up external tools, go to PyCharm settings and find **Tools > External Tools**.  Add the tools as described below. 

#### Shell Environment

For this to work, it's important that tools like `poetry` are on the system path used by PyCharm.  On Linux, depending on how you start PyCharm, your normal shell environment may or may not be inherited.  For instance, I had to adjust the target of my LXDE desktop shortcut to be the script below, which sources my profile before running the `pycharm.sh` shell script:

```sh
#!/bin/bash
source ~/.bash_profile
/opt/local/lib/pycharm/pycharm-community-2020.3.2/bin/pycharm.sh
```

#### Format Code

|Field|Value|
|-----|-----|
|Name|`Format Code`|
|Description|`Run the Black and isort code formatters`|
|Group|`Developer Tools`|
|Program|`$ProjectFileDir$/run`|
|Arguments|`format`|
|Working directory|`$ProjectFileDir$`|
|Synchronize files after execution|_Checked_|
|Open console for tool outout|_Checked_|
|Make console active on message in stdout|_Unchecked_|
|Make console active on message in stderr|_Unchecked_|
|Output filters|_Empty_|

##### Run MyPy Checks

|Field|Value|
|-----|-----|
|Name|`Run MyPy Checks`|
|Description|`Run the MyPy code checks`|
|Group|`Developer Tools`|
|Program|`$ProjectFileDir$/run`|
|Arguments|`mypy`|
|Working directory|`$ProjectFileDir$`|
|Synchronize files after execution|_Unchecked_|
|Open console for tool outout|_Checked_|
|Make console active on message in stdout|_Checked_|
|Make console active on message in stderr|_Checked_|
|Output filters|`$FILE_PATH$:$LINE$:$COLUMN$:.*`|

##### Run Pylint Checks

|Field|Value|
|-----|-----|
|Name|`Run Pylint Checks`|
|Description|`Run the Pylint code checks`|
|Group|`Developer Tools`|
|Program|`$ProjectFileDir$/run`|
|Arguments|`pylint`|
|Working directory|`$ProjectFileDir$`|
|Synchronize files after execution|_Unchecked_|
|Open console for tool outout|_Checked_|
|Make console active on message in stdout|_Checked_|
|Make console active on message in stderr|_Checked_|
|Output filters|`$FILE_PATH$:$LINE$:$COLUMN.*`|

##### Run Safety Checks

|Field|Value|
|-----|-----|
|Name|`Run Safety Checks`|
|Description|`Run the Safety code checks`|
|Group|`Developer Tools`|
|Program|`$ProjectFileDir$/run`|
|Arguments|`safety`|
|Working directory|`$ProjectFileDir$`|
|Synchronize files after execution|_Checked_|
|Open console for tool outout|_Checked_|
|Make console active on message in stdout|_Unchecked_|
|Make console active on message in stderr|_Unchecked_|
|Output filters|_Empty_|

## Release Process

### Documentation

Documentation at [Read the Docs](https://hcoop-meetbot.readthedocs.io/en/stable/) is generated via a GitHub hook each time code is pushed to master.  So, there is no formal release process for the documentation.

### Code

Code is released to [PyPI](https://pypi.org/project/hcoop-meetbot/).  There is a partially-automated process to publish a new release.  

> _Note:_ In order to publish code, you must must have push permissions to the GitHub repo and be a collaborator on the PyPI project.  Before running this process for the first time, you must set up a PyPI API token and configure Poetry to use it.  (See notes below.)

Ensure that you are on the `master` branch.  Releases must always be done from `master`.

Ensure that the `Changelog` is up-to-date and reflects all of the changes that will be published.  The top line must show your version as unreleased:

```
Version 0.1.0      unreleased
```

Run the release step:

```
$ run release 0.1.0
```

This updates `pyproject.toml` and the `Changelog` to reflect the released version, then commits those changes and tags the code.  Nothing has been pushed or published yet, so you can always remove the tag (i.e. `git tag -d v0.1.0`) and revert your commit (`git reset HEAD~1`) if you made a mistake.

Finally, publish the release:

```
$ run publish
```

This builds the deployment artifacts, publishes the artifacts to PyPI, and pushes the repo to GitHub.  The code will be available on PyPI for others to use after a little while, sometimes within a minute or two, and sometimes as much as half an hour later.

### Configuring the PyPI API Token

First, in your PyPI [account settings](https://pypi.org/manage/account/), create an API token with upload permissions for the hcoop-meetbot project.

Once you have the token, you will configure Poetry to use it.  Poetry relies on the Python keyring to store this secret.  On MacOS, it will use the system keyring, and no other setup is required.  

On Debian, the process is more complicated (see the the [keyring documentation](https://pypi.org/project/keyring/) for more details).  

First, install a keyring manager, and then log out:

```
$ sudo apt-get install gnome-keyring
$ exit
```

Log back in and initialize your keyring by setting and then removing a dummy value:

```
$ keyring set testvalue "user"
Password for 'user' in 'testvalue': 
Please enter password for encrypted keyring: 

$ keyring get testvalue "user"
Please enter password for encrypted keyring: 
password

$ keyring del testvalue "user"
Deleting password for 'user' in 'testvalue':
```

At this point, the keyring should be fully functional.

Now, configure Poetry following the [instructions](https://python-poetry.org/docs/repositories/#configuring-credentials):

```
poetry config pypi-token.pypi <the PyPI token>
```

You will have to type in the same keyring password that you set above.  Note that this leaves your actual secret in the command-line history, so make sure to scrub it once you're done.

> _Note:_ The user experience is frankly terrible if you're trying to work on a simple SSH session outside of a Linux desktop.  The GNOME keyring manager wants to pop up its dialog to accept your credentials to unlock the keyring.  That won't work on an SSH session where there is no GUI.  One alternative is to follow the notes in the [keyring documentation](https://pypi.org/project/keyring/) under **Using Keyring on headless Linux systems**.  This gives you a way to unlock the keyring inside a DBUS session. 

> The documented process does work, but it's slow and clunky.  And _you must keep the DBUS session open in a separate terminal window for as long as you need to use the keyring_.  When the instructions say "enter your password and type CTRL-D", they mean that literally.  Don't press Enter first or anything like that.  I've found that it works best if I enter the password and press CTRL-D twice so I get back to the DBUS `$` prompt before proceeding in another window.
